#include <FEHLCD.h>
#include <FEHIO.h>
#include <FEHUtility.h>
#include <FEHAccel.h>
#include <stdlib.h>
//#include <vector>

#define number_of_enemies 15

void play();
bool checkHit();
void display();
bool checkEdge(int, int);
float xTouch;
float yTouch;

void menu();

class Player
{
public:
    Player(char = 'a', int = 50, int = 50);
    void move();
    void display();


private:
    char playerChar;// the char for displaying the character
   int positionX, positionY;
   // x is always less than 320 and y less than 240
};


class Enemy
{
public:
    Enemy( int startx = 0, int starty =0, int endx= 0, int endy = 0, int speed = 0);
    void moveEnemy();
    void displayEnemies();

private:
    int positionX, positionY;// screen size is 320 by 240
    // x is always less than 320 and y less than 240
    int speed;// measured in pixels per cycle
    int beginX, beginY;
    int endX, endY;
    int radius;// measured in pixels; we'll display these later using
    // FEHLCD .FillCircle will be used to draw them
};

Player p; //creating player object p

Enemy enemyArray[number_of_enemies];

int start;

int main(void) //Written by Andy
{
    LCD.Clear(BLACK);
    menu();

}

void menu()
{


        //main method display
        LCD.WriteLine("Welcome!");
        LCD.WriteLine("1.) New Game");
        LCD.WriteLine("2.) Leaderboards");
        LCD.WriteLine("3.) Quit");
        float xTouch, yTouch;
        bool test = true;
        while(test)
        {
            if(LCD.Touch(&xTouch,&yTouch))
            {
            if (xTouch<(12*12) && (yTouch >17 && yTouch <= 17*2))
                play();
            else if (xTouch<12*16 && (yTouch >17*2 && yTouch <= 17*3))
                int unnecessary = 3;//call leaderboard method
            else if (xTouch<12*8 && (yTouch >17*3 && yTouch <= 17*4))
            {
                //LCD.DrawRectangle(80,90, 160, 60);
                //LCD.WriteAt("Are you sure?", )
                LCD.Clear(BLACK);
                LCD.WriteLine("Goodbye");
                test = false;
            }

            }
        }

}

void play()
{
    // int start = TimeNow();
        int end = TimeNow();
        int mTime;
        while(!checkHit())
        {
            LCD.Clear(BLUE);
            p.display();//displaying every object at current location
            for(int i = 0; i < number_of_enemies; i++)
            {
                enemyArray[i].displayEnemies();
            }

            mTime = TimeNow()-end; //getting time since last move

            p.move(); //updating location of player
            //moveEnemies(mTime); //updating locaiton of every enemy with mTime affecting speed

            end = TimeNow();//keeping track of total time




    for(int i = 0; i < number_of_enemies; i++)
    {
        // start and end x should be between 0 and 319
        // start and end y should be between 0 and 239
        // start x, start y, end x, end y, speed

        // all enemies should start at the top and end at the bottom for now
        enemyArray[i] = Enemy(rand() % 320,0,rand() % 320, 239, 1);
        //
    }



        /*if((end-start)%2.==0)
        {
            enemyVector.add(Enemy(rand x, rand y, speed))
        }*/
    }
}

Player::Player(char a, int x, int y)
{
    positionX = x;
    positionY = y;
    playerChar = a;
}



Enemy::Enemy(int startX, int startY, int finalX, int finalY, int speed)
{
     beginX = startX;
     beginY = startY;
     endX = finalX;
     endY = finalY;
     speed = 1;
     radius = 5;

}
void Player::display()
{

    LCD.WriteAt(playerChar,positionX,positionY);

}

void Player::move()
{
    float x = Accel.X();
    float y = Accel.Y();


    if(!checkEdge(positionX,positionY))
    {
        positionX+=x*10;
        positionY-=y*10;
    }
    else
    {
        if (positionX+12>=319)
        {
             positionY-=y*10;
             if (x<0)
                 positionX+=x*10;
        }
        if (positionY<=0)
        {
             positionX+=x*10;
             if (y<0)
                 positionY-=y*10;
        }
        if (positionX<=0)
        {
             positionY-=y*10;
             if (x>0)
                 positionX+=x*10;
        }
        if (positionY+17>=239)
        {
             positionX+=x*10;
             if (y>0)
                 positionY-=y*10;
        }

    }
}

bool checkEdge(int x, int y)
{
    if((x <= 0 || x+ 12 >= 319) || (y <= 0 || y + 17 >= 239))
    {
        // if the x is less than zero or greater than 320 pixels, OR
        // if the y is less than zero or greater than 240 pixels
            // it is indeed at or past the edge
       return true;


    }
    else return false;

}

bool checkHit()
{
    /*for(each Enemy in enemyVector)
    {
        if (p.positionX == e.positionX && p.positionY == e.positionY)
            return true;
    }*/

    return false;
}

void Enemy::moveEnemy()
{
    // for all enemies on screen

    if(TimeNow() - start > .20)
    {

    for(int i = 0; i < number_of_enemies; i++)
    {
        // move them one pixel down
        // if it is at the edge, move it
        int enemyPosX = enemyArray[i].positionX;
        int enemyPosY = enemyArray[i].positionY;
        if(!checkEdge(enemyPosX,enemyPosY))
        {
            //if not at the edge, move the enemy
            enemyArray[i].positionY ++;
            // check if each enemy is at the ednge
        }
        else
        {
             //if it IS at the edge
            // set the start to the former finish
            /*
            enemies[i].beginX = enemies[i].endX;
            enemies[i].beginY = enemies[i].endY;*/
            //for now, just set the position back to the start
            enemyArray[i].positionX = enemyArray[i].beginX;
            enemyArray[i].positionY = enemyArray[i].beginY;
        }

    }
}

}

void Enemy::displayEnemies()
{

    LCD.FillCircle(positionX, positionY, radius);
}
