#include <FEHLCD.h>
#include <FEHIO.h>
#include <FEHUtility.h>
#include <FEHAccel.h>
#include <stdlib.h>
//#include <vector>

#define number_of_enemies 2

void play();
bool checkHit();
void display();
bool checkEdge(int, int);



void menu();

class Player
{
public:
    Player(char = 'a', int = 160, int = 120);
    void move();
    void display();



    char playerChar;// the char for displaying the character
   int positionX, positionY;
   // x is always less than 320 and y less than 240
};

class Enemy
{
public:
    Enemy(int y = 0, int s = 1, int lEdge = rand() % 289, int rEdge = 0);
    void moveEnemy();
    void display();
    void setStartPositions(int i);


    int positionY;// screen size is 320 by 240
    // x is always less than 320 and y less than 240
    int speed;// measured in pixels per cycle
    int leftEdge, rightEdge;


};

Player p; //creating player object p

Enemy enemyArray[number_of_enemies];

int start;

int main(void) //Written by Andy
{

    LCD.Clear(BLACK);
    menu();

}

void menu()
{

        LCD.Clear(BLACK);
        //main method display
        LCD.WriteLine("Welcome!");
        LCD.WriteLine("1.) New Game");
        LCD.WriteLine("2.) Leaderboards");
        LCD.WriteLine("3.) Quit");
        float xTouch, yTouch;
        bool test = true;
        while(test)
        {
            if(LCD.Touch(&xTouch,&yTouch))
            {
            if (xTouch<(12*12) && (yTouch >17 && yTouch <= 17*2))
                play();
            else if (xTouch<12*16 && (yTouch >17*2 && yTouch <= 17*3))
                int unnecessary = 3;//call leaderboard method
            else if (xTouch<12*8 && (yTouch >17*3 && yTouch <= 17*4))
            {
                //LCD.DrawRectangle(80,90, 160, 60);
                //LCD.WriteAt("Are you sure?", )
                LCD.Clear(BLACK);
                LCD.WriteLine("Goodbye");
                test = false;
            }

            }
        }

}
void play()
{
    // int start = TimeNow();
        int end = TimeNow();
        int mTime;
        for(int i = 0; i < number_of_enemies; i++)
        {
            enemyArray[i].setStartPositions(i);
        }
        while(!checkHit())
        {
            LCD.Clear(BLUE);
            p.display();//displaying every object at current location

            for(int i = 0; i < number_of_enemies; i++)
            {
                enemyArray[i].display();
                enemyArray[i].moveEnemy();
            }

            mTime = TimeNow()-end; //getting time since last move

            p.move(); //updating location of player
            //moveEnemies(mTime); //updating locaiton of every enemy with mTime affecting speed

            end = TimeNow();//keeping track of total time

    }

    LCD.Clear(RED);
    LCD.WriteLine("You Lose. Your score was:");
    LCD.WriteLine(end);
    Sleep(5.);
    menu();
}

Player::Player(char a, int x, int y)
{
    positionX = x;
    positionY = y;
    playerChar = a;
}

void Enemy::setStartPositions(int i)
{

        // for the first, set its position at the top of the screen
        // for each subsequent, subtract its position by i multiples of ((1/number_of_enemies) * 240)
        positionY = (i*((1/number_of_enemies)*240));




}

Enemy::Enemy(int posY, int SpeedNew, int leftEdgeNew, int rightEdgeNew)
{

    //y position will depend on number of enemies;
    positionY = posY;
    speed = 1;
    leftEdge = leftEdgeNew;
    rightEdge = leftEdgeNew+30;

}

void Player::display()
{

    LCD.WriteAt(playerChar,positionX,positionY);

}
void Enemy::display()
{
    for (int i = 0; i < number_of_enemies; i++)
    {
        LCD.DrawRectangle(0,enemyArray[i].positionY,enemyArray[i].leftEdge, 4);
        LCD.DrawRectangle(enemyArray[i].leftEdge+30, enemyArray[i].positionY,319-(enemyArray[i].leftEdge+30),4);

    }

}

void Player::move()
{
    float x = Accel.X();
    float y = Accel.Y();


    if(!checkEdge(positionX,positionY))
    {
        positionX+=x*10;
        positionY-=y*10;
    }
    else
    {
        if (positionX+12>=319 && positionY<=0) //checking top right corner
        {
            if (x<0)
                positionX+=x*10;
            if (y<0)
                positionY-=y*10;

        }
        else if (positionX+12>=319 && positionY+17>=239) //checking bottom right corner
        {
            if (x<0)
                positionX+=x*10;
            if (y>0)
                positionY-=y*10;

        }
        else if (positionX<=0 && positionY<=0) //checking top left corner
        {
            if (x>0)
                positionX+=x*10;
            if (y<0)
                positionY-=y*10;

        }
        else if (positionX<=0 && positionY+17>=0) //checking bottom left corner
        {
            if (x>0)
                positionX+=x*10;
            if (y>0)
                positionY-=y*10;

        }
        else if (positionX+12>=319) // checking right side
        {
             positionY-=y*10;
             if (x<0)
                 positionX+=x*10;
        }
        else if (positionY<=0)//checking top side
        {
             positionX+=x*10;
             if (y<0)
                 positionY-=y*10;
        }
        else if (positionX<=0) //checking left side
        {
             positionY-=y*10;
             if (x>0)
                 positionX+=x*10;
        }
        else if (positionY+17>=239) //checking bottom side
        {
             positionX+=x*10;
             if (y>0)
                 positionY-=y*10;
        }

    }
}

bool checkEdge(int x, int y)
{
    if((x <= 0 || x+ 12 >= 319) || (y <= 0 || y + 17 >= 239))
    {
        // if the x is less than zero or greater than 320 pixels, OR
        // if the y is less than zero or greater than 240 pixels
            // it is indeed at or past the edge
       return true;


    }
    else return false;

}

bool checkHit()
{
    for (int i = 0; i < number_of_enemies; i++)
    {
        if(p.positionX<=enemyArray[i].leftEdge && (p.positionY >= enemyArray[i].positionY && p.positionY <= enemyArray[i].positionY+4))
            return true;
    }
    return false;
}
void Enemy::moveEnemy()
{
    // just increment the y position by the speed

    //if it is not touching the bottom edge
    if(positionY < 239)
    {
        positionY = positionY + speed;
    }else if(positionY >= 239)// if it is at the bottom edge or below it, set to zero and create a new hole position
    {
        positionY = 0;
        leftEdge = rand() % 289;
        rightEdge = leftEdge + 30;
    }

}
